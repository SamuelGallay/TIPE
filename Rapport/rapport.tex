\documentclass{article}

\usepackage[T1]{fontenc}

\usepackage{natbib}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{parskip}
\usepackage{minted}

\usepackage[french]{babel}

\hypersetup{
  colorlinks = true,
  breaklinks,
  citecolor = [rgb]{.12,.54,.11},
  linkcolor = {blue},
  urlcolor = {blue},
}

\geometry{verbose,tmargin=1in,bmargin=1in,lmargin=0.7in,rmargin=0.7in}

\title{Programmation Logique}
\author{\textsc{Samuel Gallay}}

\begin{document}

\maketitle

\section{Introduction}

Pendant mon TIPE, je me suis intéressé à la programmation logique, et plus particulièrement au langage \textsc{Prolog}. Initialement je souhaitais comprendre comment fonctionnaient les langages de programmation, et j'ai été attiré par l'apparence un peu atypique du langage \textsc{Prolog}. J'ai décidé d'écrire en \textsc{OCaml} un interpréteur pour ce langage.

J'ai fourni à la fin de ce rapport l'intégralité du code \textsc{OCaml} de mon interpréteur. Puisque relire le code d'autrui est rarement une chose amusante, une version en ligne de cet interpréteur est accessible à cette adresse : \url{https://samuelgallay.github.io/prolog/}. Elle permet de l'essayer dans un navigateur. J'en discuterai un peu par la suite.

Ce document suppose que le lecteur a déjà entendu parler du langage \textsc{Prolog}, ou au moins que ce dernier a parcouru dans les grandes lignes la page \textsc{Wikipédia} consacrée au \textsc{Prolog}.

\section{La grammaire du langage}

\begin{minted}{prolog}
apprend(eve, mathematiques).
apprend(benjamin, informatique).
apprend(benjamin, physique).
enseigne(alice, physique).
enseigne(pierre, mathematiques).
enseigne(pierre, informatique).

etudiant(E,P) :- apprend(E,M), enseigne(P,M).
\end{minted}

Ci-dessus est présenté un exemple de programme \textsc{Prolog}. Les briques élémentaires d'un programme sont les \emph{termes} : \mintinline{prolog}{eve}, \mintinline{prolog}{apprend(eve, mathématiques)} et \mintinline{prolog}{E} sont des termes. Une \emph{clause} se termine par un point, et contient soit un unique terme, soit un terme et une liste de termes.

J'ai défini  la grammaire du sous-ensemble du langage \textsc{Prolog} que je souhaitais interpréter. J'ai finalement choisi cette forme, qui ajoute des listes à l'exemple précédent, ainsi que des variables sans nom '\_'.

\begin{verbatim}
<Caractère>    ::=  'a'..'z' | 'A'..'Z' | '_' | '0'..'9'
<Mot>          ::=  <Caractère> | <Caractère> <Mot>
<Prédicat>     ::=  'a'..'z' | 'a'..'z' <Mot>
<Variable>     ::=  'A'..'Z' | 'A'..'Z' <Mot> | '_'
<Programme>    ::=  <Clause> | <Clause> <Programme>
<Clause>       ::=  <Terme> '.' | <Terme> ':-' <ListeTermes> '.'
<ListeTermes>  ::=  <Terme> | <Terme> ',' <ListeTermes>
<Terme>        ::=  <Variable> | <Predicat> | <Predicat> '(' <ListeTermes> ')' | <ListeProlog>
<ListeProlog>  ::=  '[]' | '[' <ListeTermes> ']' | '[' <ListeTermes> '|' <ListeProlog> ']' 
                    | '[' <ListeTermes> '|' <Variable> ']'
\end{verbatim}

\section{Représentation d'un programme \textsc{Prolog}}

C'est une partie de mon travail qui m'a demandé plusieurs essais infructueux. Il est assez naturel de représenter un terme par un type somme récursif. Le souci est que de nombreuses fonctions dans le code n'ont de sens que si les termes qu'elles prennent en argument possèdent des propriétés particulières : certaines fonctions n'accèptent que des variables, d'autres que des listes, etc... En plus une variable peut représenter une liste, ce qui complique les choses.

L'utilisation des \emph{variants polymorphes} d'\textsc{OCaml}, en particulier avec les mécanismes de \emph{coercion} rendent le code plus clair. Ces variants permettent de forcer les queues des listes \textsc{Prolog} à être elles-même des listes. Pour préserver cet invariant, je distingue deux types de variables : celles qui peuvent représenter n'importe quel terme et celles qui ne peuvent représenter que des listes.

\begin{minted}{ocaml}
type id = Id of string * int

type term =
  [ `GeneralVar of id
  | `ListVar of id
  | `EmptyList
  | `List of term * prolog_list
  | `Predicate of string * term list ]

and prolog_list = [ `ListVar of id | `EmptyList | `List of term * prolog_list ]

type var = [ `GeneralVar of id | `ListVar of id ]

type clause = Clause of term * term list
\end{minted}

\section{L'analyse syntaxique}

L'analyse syntaxique est la transformation d'une chaîne de caractères représentant un programme en un arbre de syntaxe abstraite. Il existe plusieurs bibliothèques en \textsc{OCaml}, par exemple \textsc{Menhir}, qui permettent d'écrire des grammaires dans une forme très proche de celle de \textsc{Backus-Naur} et qui génèrent le code effectuant cette transformation.

J'ai quand même décidé d'écrire moi-même un analyseur syntaxique récursif descendant. Ma première source était \cite{Ljunglof}. Je me suis rendu compte, en testant sur de longs programmes, que ma première implémentation était peu efficace. Quand plusieurs règles de production étaient disponnibles, j'effectuais un backtracking : la complexité était vraiment catastrophique. J'ai ensuite réalisé, en factorisant ma grammaire à gauche (donc en ajoutant des symboles non-terminaux), que celle-ci était $LL(1)$. J'ai pu écrire un parser sans backtracking en observant un symbole à l'avance à chaque fois. Pour simplifier un petit peu, j'ai d'abord écrit un lexer qui reconnait les symboles élémentaires.

Cette dernière implémentation est moins élégante, mais très rapide. Je peux analyser des fichiers d'un Mo en environ une seconde à environ 1GHz.

Enfin, puisque je différencie deux types de variables, je dois rechercher toutes les variables qui sont la queue d'une liste, et indiquer quelles sont des listes dans toutes leurs occurences.

Au final le code est peu lisible. J'ai utilisé de nombreux opérateurs infix, et j'ai encapsulé mes résultats dans un type \mintinline{ocaml}{result}
\footnote{\mintinline{ocaml}{type ('a, 'e) result = Ok of 'a | Error of 'e}}
 pour transmettre des messages d'erreur.

\section{L'unification}

Les deux algorithmes à la base de \textsc{Prolog} sont l'unification et le principe de résolution, qui ont été introduits par \cite{Robinson}. Je ne vais pas rappeler son fonctionnement, mais l'unification prend en paramètres deux termes $t_1$ et $t_2$ ne possédant pas de variables en commun : ceci justifie l'utilisation d'un entier dans mes identifiants, pour permettre un renommage facile. L'algorithme renvoie si elle existe la substitution $\sigma$ (fonction des variables dans les termes) la plus générale telle que $\sigma(t_1) = \sigma(t_2)$.

L'algorithme d'unification complet est présenté dans \cite{NilssonMaluszynski}.  Je l'ai adapté à ma représentation des termes, et je l'ai transformé en un algorithme récursif.

J'utilise en fait le même algorithme que \textsc{Prolog} qui est une simplification de celui présenté dans \cite{NilssonMaluszynski} : celui de \textsc{Prolog} est plus rapide mais peut ne pas terminer. Par exemple en essayant d'unifier \mintinline{prolog}{X} et \mintinline{prolog}{f(X)}, l'algorithme, à la place d'échouer, va essayer de renvoyer \mintinline{prolog}{f(f(f(...)))}.

\section{La recherche de solutions}

Je ne vais pas non plus redécrire le principe de résolution de \textsc{Prolog}. La résolution se ramène essentiellement à la construction et au parcours d'un arbre dont les noeuds portent des requêtes à résoudre, et les feuilles sont des substitutions solutions de la requête initiale. Un noeud possède plusieurs fils quand plusieurs clauses peuvent être utilisées pour résoudre la requête qu'il porte.

Puisque l'exécution d'un programme \textsc{Prolog} peut ne pas terminer, l'arbre peut être infini. On ne peut donc pas le stocker entièrement en mémoire. C'est pour cela que j'utilise l'évaluation paresseuse, qui permet d'évaluer l'arbre à la demande :

\begin{minted}{ocaml}
type 'a tree = Leaf of 'a | Node of 'a tree Lazy.t list
\end{minted}

Je trouve plus aisé d'écrire différents types de parcours sur un tel arbre que de modifier une grande fonction récursive. \textsc{Prolog} utilise un parcours en profondeur de cet arbre. C'est ce que je fais avec la fonction \mintinline{ocaml}{to_seq} de mon code qui transforme l'arbre en une séquence (liste possiblement infinie) de solutions qu'il suffit d'itérer. 

\section{Extensions}

Je me suis intéressé à différents moyens d'augmenter cet interpréteur. Une variation intéressante de l'exécution est de procéder à un parcours en largeur de l'arbre, ce qui permet d'accéder en un temps fini à chacune des solutions.

Un point qui m'a intéressé est la mémoïsation des programmes \textsc{Prolog}. On peut enregistrer les solutions des requêtes déjà traitées pour accélérer l'exécution. Ceci a été fait dans \cite{Warren}. On peut ainsi éviter des boucles infinies où l'on répèterait la même requête.

Il faut savoir que des compilateurs pour le langange ont déjà été écrits. Le premier a été celui de David H. D. Warren\footnote{Ce ne sont pas les mêmes David Warren}.

Pour créer une interface à mon interpréteur, et pouvoir le partager, j'ai compilé mon code \textsc{OCaml} en \textsc{JavaScript}\footnote{J'ai utilisé \textsc{Melange}, un fork de \textsc{BuckleScript} après que ce dernier se soit éloigné d'\textsc{OCaml}...}. Notons que l'on perd un facteur 10 dans la vitesse d'exécution par rapport à du code natif. C'est aussi pour simplifier cette compilation que j'ai réécrit un parser sans utiliser une bibliothèque existante. J'utilise quelques expressions rationnelles pour la coloration syntaxique de l'éditeur. Le programme sur la page de garde est une solution du célèbre \emph{puzzle du zèbre}\footnote{\url{https://en.wikipedia.org/wiki/Zebra_Puzzle}} !

\bibliographystyle{plainnat-fr}
\bibliography{biblio}

\appendix

\section*{Intégralité du code OCaml}
\inputminted{ocaml}{../Code/prolog.ml}

\end{document}
